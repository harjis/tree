{"version":3,"sources":["features/d3-tree/components/Tree/Tree.module.css","features/d3-tree/components/Canvas/Canvas.tsx","features/d3-tree/components/Cluster/Cluster.tsx","features/d3-tree/components/Cluster/Cluster-d3.ts","hooks/useRefCallbackWithCleanup.ts","hooks/useHotkeys.ts","features/d3-tree/components/Tree/Tree.tsx","features/d3-tree/utils/stratify.ts","hooks/useHighlightedTreeItem.ts","dataGenerator/index.ts","utils/numberUtil.ts","hooks/useSelectedTreeOptimized.ts","hooks/useSearch.ts","hooks/useSelectedItems.ts","hooks/useSelectedTree.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","Canvas","props","ref","React","useRef","useState","viewBox","setViewBox","useEffect","current","svg","getBBox","x","y","width","height","autoBox","display","join","children","Cluster","typedMemo","memo","wrapper","selection","select","selectAll","remove","pathWrapper","append","attr","pointsWrapper","textWrapper","dy","tree","root","nodeSize","data","links","d","selectedItemIds","has","String","target","id","source","descendants","highlightedItemId","text","labelKey","filter","clone","lower","render","noop","useHotkeys","autoFocus","eventListeners","callback","cleanUpRef","useCallback","element","useRefCallbackWithCleanup","handlers","forEach","keys","eventListener","eventHandler","event","includes","key","push","addEventListener","focus","console","log","handler","removeEventListener","hookStart","hookEnd","Tree","useMemo","items","idKey","parentId","parentKey","d3Stratify","useSelectedTreeFn","performance","mark","itemKey","search","onSearch","measure","name","getEntriesByType","duration","clearMeasures","highlightedTreeItem","setHighlightedItemId","stopPropagation","currentlyHighlightedItemId","highLightedItem","find","selectFirstChild","parent","selectParent","siblings","each","depth","currentIndex","findIndex","sibling","selectTopSideSibling","selectBottomSideSibling","hotkeyRef","useHighlightedTreeItem","className","s","container","tabIndex","type","value","onChange","currentTarget","canvasContainer","folderId","nextId","generate","itemsOnLevel","createFolder","concat","generateForLevel","folders","currentDepth","reduce","acc","folder","size","startAt","Array","map","i","range","itemNumber","generateChildren","temp","folderArgs","useSelectedTreeOptimized","setSearch","debouncedSearch","setDebouncedSearch","useDebounce","itemsTemp","Set","length","treeItem","filteredItemValue","toLocaleLowerCase","toLowerCase","selectedNodes","node","path","a","add","useSearch","options","filteredItems","setFilteredItems","doSearch","caseSensitive","filteredItem","caseSensitiveFilteringService","filteringService","useSelectedTree","selectedItems","useSelectedItems","flatMap","selectedItem","getSelectedNodes","getSelectedNodesAndAllTheirParents","App","combined","itemLength","style","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8eba2ac1.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Tree_container__14Gk0\",\"canvasContainer\":\"Tree_canvasContainer__2vhw0\"};","import React from \"react\";\n\nexport type Props = {\n  height: number;\n  width: number;\n};\nexport const Canvas: React.FC<Props> = (props) => {\n  const ref = React.useRef<SVGSVGElement>(null);\n  const [viewBox, setViewBox] = React.useState([0, 0, 0, 0]);\n  React.useEffect(() => {\n    if (ref.current) {\n      setViewBox(autoBox(ref.current));\n    }\n  }, []);\n  return (\n    <svg\n      ref={ref}\n      display=\"block\"\n      height={props.height}\n      width={props.width}\n      viewBox={viewBox.join(\" \")}\n    >\n      {props.children}\n    </svg>\n  );\n};\n\nfunction autoBox(svg: SVGSVGElement) {\n  const { x, y, width, height } = svg.getBBox();\n  return [x, y, width, height];\n}\n","import React from \"react\";\nimport { HierarchyNode } from \"d3\";\n\nimport { render } from \"./Cluster-d3\";\n\nexport type Props<T> = {\n  height: number;\n  highlightedItemId: string | undefined;\n  labelKey: keyof T;\n  tree: HierarchyNode<T>;\n  selectedItemIds: Set<string>;\n  width: number;\n};\n\nconst InternalCluster = <T,>(props: Props<T>) => {\n  const ref = React.useRef<SVGGElement>(null);\n\n  React.useEffect(() => {\n    if (ref.current) {\n      render(ref.current, props);\n    }\n  }, [props]);\n  return <g ref={ref} />;\n};\n\n// Memo hack: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/37087#issuecomment-568218789\ninterface IdentityFunction {\n  <T>(fn: T): T;\n}\nconst typedMemo: IdentityFunction = React.memo;\nexport const Cluster = typedMemo(InternalCluster);\n","import { select, tree } from \"d3\";\nimport { Props } from \"./Cluster\";\n\nexport const render = <T>(wrapper: SVGGElement, props: Props<T>) => {\n  const selection = select(wrapper);\n  selection.selectAll(\"g\").remove();\n\n  const pathWrapper = selection\n    .append(\"g\")\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"#555\")\n    .attr(\"stroke-opacity\", 0.4)\n    .attr(\"stroke-width\", 1.5);\n  const pointsWrapper = selection.append(\"g\");\n  const textWrapper = selection.append(\"g\");\n\n  const dx = 50;\n  const dy = props.width / (props.tree.height + 1);\n  const root = tree<T>().nodeSize([dx, dy])(props.tree);\n\n  pathWrapper\n    .selectAll(\"path\")\n    .data(root.links())\n    .join(\"path\")\n    .attr(\"stroke\", (d) => {\n      if (props.selectedItemIds.has(String(d.target.id))) {\n        return \"blue\";\n      } else {\n        return \"#555\";\n      }\n    })\n    .attr(\n      \"d\",\n      (d) => `\n        M${d.target.y},${d.target.x}\n        C${d.source.y + dy / 2},${d.target.x}\n         ${d.source.y + dy / 2},${d.source.x}\n         ${d.source.y},${d.source.x}\n      `\n    );\n\n  pointsWrapper\n    .selectAll(\"circle\")\n    .data(root.descendants())\n    .join(\"circle\")\n    .attr(\"cx\", (d) => d.y)\n    .attr(\"cy\", (d) => d.x)\n    .attr(\"fill\", (d) => (d.children ? \"#555\" : \"#999\"))\n    .attr(\"r\", 2.5);\n\n  textWrapper\n    .attr(\"font-family\", \"sans-serif\")\n    .attr(\"font-size\", 10)\n    .attr(\"stroke-linejoin\", \"round\")\n    .attr(\"stroke-width\", 3)\n    .selectAll(\"text\")\n    .data(root.descendants())\n    .join(\"text\")\n    .attr(\"x\", (d) => d.y)\n    .attr(\"y\", (d) => d.x)\n    .attr(\"dy\", \"0.31em\")\n    .attr(\"dx\", (d) => (d.children ? -6 : 6))\n    .attr(\"fill\", (d) => {\n      if (d.id === props.highlightedItemId) return \"red\";\n      // d.id && -> because d3 type is id?: string;\n      return d.id && props.selectedItemIds.has(d.id) ? \"blue\" : \"black\";\n    })\n    .text((d) => String(d.data[props.labelKey]))\n    .filter((d) => !!d.children)\n    .attr(\"text-anchor\", \"end\")\n    .clone(true)\n    .lower()\n    .attr(\"stroke\", \"white\");\n};\n","import React from \"react\";\n\ntype Cleanup = () => void;\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop: Cleanup = () => {};\n\ntype RefCallbackWithoutCleanup<RefElement extends HTMLElement> = (\n  element: RefElement | null\n) => void;\nexport type RefCallbackWithCleanup<RefElement extends HTMLElement> = (\n  element: RefElement\n) => () => void;\n\n/*\n * The idea of this hook is to generalize cleanup for RefCallback.\n * By default React.RefCallback doesn't support cleanup.\n * */\nexport function useRefCallbackWithCleanup<RefElement extends HTMLElement>(\n  callback: RefCallbackWithCleanup<RefElement>\n): RefCallbackWithoutCleanup<RefElement> {\n  const cleanUpRef = React.useRef<Cleanup>(noop);\n  return React.useCallback(\n    (element: RefElement | null) => {\n      cleanUpRef.current();\n      // So that every cleanup is called only once\n      cleanUpRef.current = noop;\n\n      if (element) {\n        cleanUpRef.current = callback(element);\n      }\n    },\n    [callback]\n  );\n}\n","import React from \"react\";\nimport {\n  RefCallbackWithCleanup,\n  useRefCallbackWithCleanup,\n} from \"./useRefCallbackWithCleanup\";\n\nexport type EventListener = {\n  keys: string[];\n  eventListener: (event: KeyboardEvent) => void;\n};\ntype Handler = (event: KeyboardEvent) => void;\ntype Props = {\n  autoFocus: boolean;\n  eventListeners: EventListener[];\n};\nexport const useHotkeys = <RefElement extends HTMLElement>(\n  props: Props\n): React.RefCallback<RefElement> => {\n  const { autoFocus, eventListeners } = props;\n  const refCallback: RefCallbackWithCleanup<RefElement> = React.useCallback(\n    (element) => {\n      const handlers: Handler[] = [];\n      eventListeners.forEach(({ keys, eventListener }) => {\n        const eventHandler = (event: KeyboardEvent) => {\n          if (keys.includes(event.key)) {\n            eventListener(event);\n          }\n        };\n        handlers.push(eventHandler);\n        element?.addEventListener(\"keydown\", eventHandler);\n      });\n\n      if (autoFocus) {\n        element?.focus();\n      }\n\n      return () => {\n        console.log(\"Cleanup time!\");\n        handlers.forEach((handler) => {\n          element?.removeEventListener(\"keydown\", handler);\n        });\n      };\n    },\n    [autoFocus, eventListeners]\n  );\n  return useRefCallbackWithCleanup<RefElement>(refCallback);\n};\n","import React, { PropsWithChildren } from \"react\";\n\nimport s from \"./Tree.module.css\";\n\nimport { BaseItem } from \"../../types\";\nimport { Canvas } from \"../Canvas\";\nimport { Cluster } from \"../Cluster\";\nimport { stratify } from \"../../utils/stratify\";\nimport { useHighlightedTreeItem } from \"../../../../hooks/useHighlightedTreeItem\";\nimport { IUseSelectedTree } from \"../../../../hooks/IUseSelectedTree\";\n\nexport const hookStart = \"hook-start\";\nexport const hookEnd = \"hook-end\";\n\nexport type Props<T> = {\n  height: number;\n  idKey: keyof T;\n  items: T[];\n  labelKey: keyof T;\n  parentKey: keyof T;\n  width: number;\n  useSelectedTreeFn: IUseSelectedTree;\n};\nexport const Tree = <T extends BaseItem>(\n  props: PropsWithChildren<Props<T>>\n) => {\n  // In our app all d3 related stuff could be completely inside the useSelectedTreeOptimized hook\n  // I have them here because Cluster takes tree as props\n  const tree = React.useMemo(\n    () => stratify(props.items, props.idKey, props.parentKey),\n    [props.items, props.idKey, props.parentKey]\n  );\n  const { useSelectedTreeFn } = props;\n  performance.mark(hookStart);\n  const { search, onSearch, selectedItemIds } = useSelectedTreeFn({\n    items: props.items,\n    itemKey: props.labelKey,\n    tree,\n  });\n  performance.mark(hookEnd);\n  performance.measure(\"measure hook-start to hook-end\", hookStart, hookEnd);\n\n  console.log(\n    `Hook performance (${useSelectedTreeFn.name}): ${\n      performance.getEntriesByType(\"measure\")[0].duration\n    }ms`\n  );\n  performance.clearMeasures();\n\n  const highlightedTreeItem = useHighlightedTreeItem({ tree });\n\n  return (\n    <div\n      className={s.container}\n      tabIndex={0}\n      ref={highlightedTreeItem.hotkeyRef}\n    >\n      Press arrow keys to navigate! <br />\n      Search:{\" \"}\n      <input\n        type=\"text\"\n        value={search}\n        onChange={(event) => {\n          const value = event.currentTarget.value;\n          onSearch(value);\n        }}\n      />\n      <div className={s.canvasContainer}>\n        <Canvas height={props.height} width={props.width}>\n          <Cluster\n            height={props.height}\n            highlightedItemId={highlightedTreeItem.highlightedItemId}\n            labelKey={props.labelKey}\n            tree={tree}\n            selectedItemIds={selectedItemIds}\n            width={props.width}\n          />\n        </Canvas>\n      </div>\n    </div>\n  );\n};\n","import { stratify as d3Stratify } from \"d3\";\n\nexport const stratify = <T>(data: T[], id: keyof T, parentId: keyof T) => {\n  return d3Stratify<T>()\n    .id((d) => String(d[id]))\n    .parentId((d) => {\n      // For some reason null is not acceptable parentId and it that case it should be \"\"\n      // Maybe it has something to do with CSVs since this is supposed to be used for reading CSV data\n      return d[parentId] === null ? \"\" : String(d[parentId]);\n    })(data);\n};\n","import React from \"react\";\nimport { HierarchyNode } from \"d3\";\n\nimport { useHotkeys } from \"./useHotkeys\";\n\ntype Props<Item> = {\n  tree: HierarchyNode<Item>;\n};\ntype ReturnType<Element> = {\n  hotkeyRef: React.RefCallback<Element>;\n  highlightedItemId: string | undefined;\n};\nexport const useHighlightedTreeItem = <Item, Element extends HTMLElement>(\n  props: Props<Item>\n): ReturnType<Element> => {\n  const [highlightedItemId, setHighlightedItemId] = React.useState<\n    string | undefined\n  >(props.tree.id);\n\n  // When highlightedItemId or props.tree change the previous eventlisteners get cleaned up and new ones\n  // get attached. Probably can't do anything about it\n  const eventListeners = React.useMemo(\n    () => [\n      {\n        keys: [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"],\n        eventListener: (event: KeyboardEvent) => {\n          event.stopPropagation();\n          if (event.key === \"ArrowRight\") {\n            setHighlightedItemId(\n              selectFirstChild(props.tree, highlightedItemId)\n            );\n          } else if (event.key === \"ArrowLeft\") {\n            setHighlightedItemId(selectParent(props.tree, highlightedItemId));\n          } else if (event.key === \"ArrowUp\") {\n            setHighlightedItemId(\n              selectTopSideSibling(props.tree, highlightedItemId)\n            );\n          } else if (event.key === \"ArrowDown\") {\n            setHighlightedItemId(\n              selectBottomSideSibling(props.tree, highlightedItemId)\n            );\n          }\n        },\n      },\n    ],\n    [highlightedItemId, props.tree]\n  );\n  const hotkeyRef = useHotkeys({\n    autoFocus: true,\n    eventListeners,\n  });\n\n  return {\n    hotkeyRef,\n    highlightedItemId,\n  };\n};\n\nfunction selectFirstChild<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n  if (highLightedItem.children) {\n    return highLightedItem.children[0].id;\n  }\n  return currentlyHighlightedItemId;\n}\n\nfunction selectParent<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n  if (highLightedItem.parent) {\n    return highLightedItem.parent.id;\n  }\n  return currentlyHighlightedItemId;\n}\n\nfunction selectTopSideSibling<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n\n  const siblings: HierarchyNode<Item>[] = [];\n  tree.each((d: HierarchyNode<Item>) => {\n    if (d.depth === highLightedItem.depth) {\n      siblings.push(d);\n    }\n  });\n  const currentIndex = siblings.findIndex(\n    (sibling) => sibling.id === highLightedItem.id\n  );\n\n  if (siblings[currentIndex - 1]) {\n    return siblings[currentIndex - 1].id;\n  } else {\n    return highLightedItem.id;\n  }\n}\n\n// Copy-pasta for now!\nfunction selectBottomSideSibling<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n\n  const siblings: HierarchyNode<Item>[] = [];\n  tree.each((d: HierarchyNode<Item>) => {\n    if (d.depth === highLightedItem.depth) {\n      siblings.push(d);\n    }\n  });\n  const currentIndex = siblings.findIndex(\n    (sibling) => sibling.id === highLightedItem.id\n  );\n\n  if (siblings[currentIndex + 1]) {\n    return siblings[currentIndex + 1].id;\n  } else {\n    return highLightedItem.id;\n  }\n}\n","import { range } from \"../utils/numberUtil\";\n\nlet folderId = 0;\nfunction nextId() {\n  const nextId = folderId + 1;\n  folderId = folderId + 1;\n  return nextId;\n}\n\ninterface BaseType {\n  type: string;\n}\n\ninterface Folder extends BaseType {\n  id: number;\n  name: string;\n  parentId: number | null;\n  type: \"folder\";\n}\n\nexport const generate = (depth: number, itemsOnLevel: number) => {\n  // console.log(\"fold id at start\", folderId);\n  const root = createFolder({ name: \"Root\", parentId: null });\n\n  // Yeah this isn't right :D\n  return [root].concat(generateForLevel([root], depth, itemsOnLevel, 1));\n};\n\nfunction generateForLevel(\n  folders: Folder[],\n  depth: number,\n  itemsOnLevel: number,\n  currentDepth: number\n): Folder[] {\n  return folders.reduce((acc: Folder[], folder) => {\n    const children = generateChildren(folder, currentDepth, itemsOnLevel);\n\n    let temp: Folder[] = [];\n    if (currentDepth < depth) {\n      temp = generateForLevel(children, depth, itemsOnLevel, currentDepth + 1);\n    }\n\n    return [...acc, ...children, ...temp];\n  }, []);\n}\n\nfunction generateChildren(\n  parent: Folder,\n  currentDepth: number,\n  itemsOnLevel: number\n): Folder[] {\n  return range(itemsOnLevel, 1).map((itemNumber) => {\n    return createFolder({\n      name: `Child item no. ${itemNumber} parent_id: ${parent.id} depth: ${currentDepth}`,\n      parentId: parent.id,\n    });\n  });\n}\n\nfunction createFolder(folderArgs: Omit<Folder, \"id\" | \"type\">): Folder {\n  return { ...folderArgs, id: nextId(), type: \"folder\" };\n}\n","export function range(size: number, startAt = 0) {\n  return [...Array(size).keys()].map((i) => i + startAt);\n}\n","import React, { useMemo } from \"react\";\n\nimport { useDebounce } from \"react-use\";\n\nimport { IUseSelectedTree } from \"./IUseSelectedTree\";\n\nexport const useSelectedTreeOptimized: IUseSelectedTree = (props) => {\n  const [search, setSearch] = React.useState(\"\");\n  const [debouncedSearch, setDebouncedSearch] = React.useState(\"\");\n  useDebounce(\n    () => {\n      setDebouncedSearch(search);\n    },\n    200,\n    [search]\n  );\n\n  const onSearch = (value: string): void => {\n    const resetSearch = (): void => {\n      setSearch(\"\");\n    };\n    if (value === \"\") return resetSearch();\n    // We are not setting filteredItems here on purpose. Setting only search string ends up in the effect\n    // few lines above.\n    // If hook receives new items we want to maintain the search and do it for the new items. This is\n    // why we have the effect and why it's not necessary the filter items in this function or in resetSearch\n    // setFilteredItems(doSearch(value));\n    setSearch(value);\n  };\n\n  const selectedItemIds = useMemo(() => {\n    const itemsTemp: Set<string> = new Set();\n    if (debouncedSearch.length === 0) {\n      return itemsTemp;\n    }\n    props.tree.each((treeItem) => {\n      const filteredItemValue = treeItem.data[props.itemKey];\n      if (\n        typeof filteredItemValue === \"string\" &&\n        filteredItemValue\n          .toLocaleLowerCase()\n          .includes(debouncedSearch.toLowerCase())\n      ) {\n        let selectedNodes = [treeItem];\n        if (treeItem.data.type === \"folder\" && treeItem.children) {\n          selectedNodes = selectedNodes.concat(treeItem.children);\n        }\n        selectedNodes.forEach((node) => {\n          props.tree.path(node).forEach((a) => {\n            itemsTemp.add(String(a.data.id));\n          });\n        });\n      }\n    });\n    return itemsTemp;\n  }, [props.itemKey, props.tree, debouncedSearch]);\n\n  return {\n    search,\n    onSearch,\n    selectedItemIds,\n  };\n};\n","import React from \"react\";\nimport { useDebounce } from \"react-use\";\n\nexport type Props<T> = {\n  items: T[];\n  itemKey: keyof T;\n  options?: { caseSensitive: boolean };\n};\nexport type ReturnType<T> = {\n  filteredItems: T[];\n  onSearch: (value: string) => void;\n  search: string;\n};\nexport const initialState = {\n  filteredItems: [],\n  onSearch: () => {\n    throw new Error(\"Implement onSearch\");\n  },\n  search: \"\",\n};\nexport default function useSearch<T>({\n  items,\n  itemKey,\n  options,\n}: Props<T>): ReturnType<T> {\n  const [search, setSearch] = React.useState(\"\");\n  const [filteredItems, setFilteredItems] = React.useState(items);\n  const [debouncedSearch, setDebouncedSearch] = React.useState(\"\");\n  useDebounce(\n    () => {\n      setDebouncedSearch(search);\n    },\n    200,\n    [search]\n  );\n\n  const doSearch = React.useCallback(\n    (value: string): T[] =>\n      options && options.caseSensitive\n        ? caseSensitiveFilteringService(items, itemKey, value)\n        : filteringService(items, itemKey, value),\n    [items, itemKey, options]\n  );\n\n  React.useEffect(() => {\n    setFilteredItems(doSearch(debouncedSearch));\n  }, [items, debouncedSearch, doSearch]);\n\n  const resetSearch = (): void => {\n    // setFilteredItems(items);\n    setSearch(\"\");\n  };\n\n  const onSearch = (value: string): void => {\n    if (value === \"\") return resetSearch();\n    // We are not setting filteredItems here on purpose. Setting only search string ends up in the effect\n    // few lines above.\n    // If hook receives new items we want to maintain the search and do it for the new items. This is\n    // why we have the effect and why it's not necessary the filter items in this function or in resetSearch\n    // setFilteredItems(doSearch(value));\n    setSearch(value);\n  };\n\n  return { search, filteredItems, onSearch };\n}\n\nfunction filteringService<T>(items: T[], itemKey: keyof T, value: string) {\n  return items.reduce<T[]>((acc, filteredItem) => {\n    const filteredItemValue = filteredItem[itemKey];\n    if (\n      typeof filteredItemValue === \"string\" &&\n      filteredItemValue.toLocaleLowerCase().includes(value.toLowerCase())\n    ) {\n      return [...acc, filteredItem];\n    } else {\n      return acc;\n    }\n  }, []);\n}\n\nfunction caseSensitiveFilteringService<T>(\n  items: T[],\n  itemKey: keyof T,\n  value: string\n) {\n  return items.reduce<T[]>((acc, filteredItem) => {\n    const filteredItemValue = filteredItem[itemKey];\n    if (\n      typeof filteredItemValue === \"string\" &&\n      filteredItemValue.includes(value)\n    ) {\n      return [...acc, filteredItem];\n    } else {\n      return acc;\n    }\n  }, []);\n}\n","import useSearch, { Props, ReturnType as SearchReturnType } from \"./useSearch\";\n\nexport type { Props };\nexport type ReturnType<T> = {\n  search: SearchReturnType<T>[\"search\"];\n  onSearch: SearchReturnType<T>[\"onSearch\"];\n  selectedItems: T[];\n};\nexport const useSelectedItems = <T>(props: Props<T>): ReturnType<T> => {\n  const search = useSearch(props);\n\n  return {\n    search: search.search,\n    onSearch: search.onSearch,\n    selectedItems: search.search === \"\" ? [] : search.filteredItems,\n  };\n};\n","import React from \"react\";\nimport { HierarchyNode } from \"d3\";\n\nimport { useSelectedItems } from \"./useSelectedItems\";\nimport { BaseItem } from \"../features/d3-tree/types\";\nimport { IUseSelectedTree } from \"./IUseSelectedTree\";\n\nexport const useSelectedTree: IUseSelectedTree = (props) => {\n  const { selectedItems, search, onSearch } = useSelectedItems({\n    items: props.items,\n    itemKey: props.itemKey,\n  });\n\n  const selectedItemIds = React.useMemo(() => {\n    const selectedNodes = getSelectedNodes(selectedItems, props.tree);\n    return getSelectedNodesAndAllTheirParents(props.tree, selectedNodes);\n  }, [props.tree, selectedItems]);\n\n  return {\n    search,\n    onSearch,\n    selectedItemIds,\n  };\n};\n\nfunction getSelectedNodes<T extends BaseItem>(\n  selectedItems: T[],\n  tree: HierarchyNode<T>\n): HierarchyNode<T>[] {\n  return selectedItems.flatMap((selectedItem) => {\n    // TODO It would be better to abstract folders and reports out from this and use more generic\n    // terms for node's which don't have children and which do.\n    // I think d3 uses \"leaf node\" and \"node\" respectively\n    if (selectedItem.type === \"folder\") {\n      //@ts-ignore missing from types\n      const treeItem = tree.find(\n        //@ts-ignore missing from types\n        (d) => String(d.id) === String(selectedItem.id)\n      );\n\n      const selectedNodes = [treeItem];\n      return treeItem.children\n        ? selectedNodes.concat(treeItem.children)\n        : selectedNodes;\n    } else {\n      //@ts-ignore missing from types\n      return [tree.find((d) => String(d.id) === String(selectedItem.id))];\n    }\n  });\n}\n\nfunction getSelectedNodesAndAllTheirParents<T extends BaseItem>(\n  tree: HierarchyNode<T>,\n  selectedNodes: HierarchyNode<T>[]\n): Set<string> {\n  // String(node.id) because of d3 type is id?: string; but we always have id\n  return new Set(\n    selectedNodes\n      .flatMap((node) => {\n        return tree.path(node);\n      })\n      .map((node) => String(node.id))\n  );\n}\n","import React from \"react\";\n\nimport { Tree } from \"./features/d3-tree\";\nimport { generate } from \"./dataGenerator\";\nimport { useSelectedTreeOptimized } from \"./hooks/useSelectedTreeOptimized\";\nimport { useSelectedTree } from \"./hooks/useSelectedTree\";\n\n/*\n * Perf results:\n *\n * generate(3, 10)\n * 1k nodes dev: useSelectedTree: 50ms which is ran 4 times. Whole thing with rendering ~270ms\n * 1k nodes prod: useSelectedTree: 80ms which is ran 2 times. Whole thing with rendering ~230ms\n *\n * optimized 1k nodes prod: useSelectedTree: ~100ms which is ran 1 times. Whole thing with rendering ~170ms\n * more optimized 1k nodes prod: useSelectedTree: ~100ms which is ran 1 times. Whole thing with rendering ~113ms\n *\n *\n * generate(3, 15)\n * optimized 3k nodes prod: useSelectedTree: ~800ms which is ran 1 times. Whole thing with rendering ~1s\n * more-optimized 3k nodes prod: useSelectedTree: ~800ms which is ran 1 times. Whole thing with rendering ~430ms\n *\n *\n * generate(3, 20)\n * 8k nodes dev: useSelectedTree: 2,5s which is ran 4 times. Whole thing with rendering ~10s\n * 8k nodes prod: useSelectedTree: 3,7s which is ran 2 times. Whole thing with rendering ~8s\n *\n * optimized 8k nodes dev: useSelectedTree: 2.5s which is ran 2 times. Whole thing with rendering ~5.6s\n * optimized 8k nodes prod: useSelectedTree: 3,7s which is ran 1 times. Whole thing with rendering ~4,5s\n *\n * more-optimized 8k nodes prod: useSelectedTree: 1.2s which is ran 1 times. Whole thing with rendering ~2s\n * -> Sometimes I get really weird results: search takes 20ms and whole thing around ~800ms\n * */\n\nfunction App() {\n  // const combined: Array<Report | Folder> = staticData();\n  const combined = React.useMemo(() => generate(3, 10), []);\n  const itemLength = combined.length;\n  console.log(\"items in data structure: \", itemLength);\n  let height = 1000;\n  if (itemLength < 100) {\n    height = 800;\n  } else if (itemLength < 2000) {\n    height = 40000;\n  } else if (itemLength > 2000 && itemLength < 7000) {\n    height = 130000;\n  } else if (itemLength > 7000) {\n    height = 300000;\n  }\n\n  return (\n    <div style={{ display: \"flex\", width: \"100%\" }}>\n      <div>\n        Optimised: (Or at least tries to be)\n        <Tree\n          height={height}\n          idKey=\"id\"\n          items={combined}\n          labelKey=\"name\"\n          parentKey=\"parentId\"\n          width={500}\n          useSelectedTreeFn={useSelectedTreeOptimized}\n        />\n      </div>\n\n      <div>\n        Un-optimised:\n        <Tree\n          height={height}\n          idKey=\"id\"\n          items={combined}\n          labelKey=\"name\"\n          parentKey=\"parentId\"\n          width={500}\n          useSelectedTreeFn={useSelectedTree}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n// interface BaseType {\n//   type: string;\n// }\n// interface Folder extends BaseType {\n//   id: number;\n//   name: string;\n//   parentId: number | null;\n//   type: \"folder\";\n// }\n// interface Report extends BaseType {\n//   id: number;\n//   name: string;\n//   parentId: number | null;\n//   type: \"report\";\n// }\n//\n// function staticData() {\n//   const folders: Folder[] = [\n//     { id: 1, name: \"Root\", parentId: null, type: \"folder\" },\n//     { id: 2, name: \"Cats\", parentId: 1, type: \"folder\" },\n//     { id: 3, name: \"Dogs\", parentId: 1, type: \"folder\" },\n//     { id: 4, name: \"Small\", parentId: 2, type: \"folder\" },\n//     { id: 5, name: \"Big\", parentId: 2, type: \"folder\" },\n//     { id: 6, name: \"Empty folder\", parentId: 1, type: \"folder\" },\n//   ];\n//\n//   const reports: Report[] = [\n//     { id: 10, name: \"Kitten\", parentId: 4, type: \"report\" },\n//     { id: 20, name: \"Kitten2\", parentId: 4, type: \"report\" },\n//     { id: 30, name: \"Buldog\", parentId: 3, type: \"report\" },\n//     { id: 40, name: \"Under root\", parentId: 1, type: \"report\" },\n//     { id: 50, name: \"Fatcat\", parentId: 5, type: \"report\" },\n//   ];\n//\n//   return [...folders, ...reports];\n// }\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\n\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}