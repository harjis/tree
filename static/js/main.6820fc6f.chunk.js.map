{"version":3,"sources":["features/d3-tree/components/Tree/Tree.module.css","features/d3-tree/components/Canvas/Canvas.tsx","features/d3-tree/components/Cluster/Cluster.tsx","features/d3-tree/components/Cluster/Cluster-d3.ts","hooks/useRefCallbackWithCleanup.ts","hooks/useHotkeys.ts","features/d3-tree/components/Tree/Tree.tsx","features/d3-tree/utils/stratify.ts","hooks/useSelectedTree.ts","hooks/useHighlightedTreeItem.ts","dataGenerator/index.ts","utils/numberUtil.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","Canvas","props","ref","React","useRef","useState","viewBox","setViewBox","useEffect","current","svg","getBBox","x","y","width","height","autoBox","display","join","children","Cluster","wrapper","selection","select","selectAll","remove","pathWrapper","append","attr","pointsWrapper","textWrapper","dy","tree","root","nodeSize","data","links","d","selectedItemIds","has","String","target","id","source","descendants","highlightedItemId","text","labelKey","filter","clone","lower","render","noop","useHotkeys","autoFocus","eventListeners","callback","cleanUpRef","useCallback","element","useRefCallbackWithCleanup","handlers","forEach","keys","eventListener","eventHandler","event","includes","key","push","addEventListener","focus","console","log","handler","removeEventListener","Tree","useMemo","items","idKey","parentId","parentKey","d3Stratify","search","setSearch","itemsTemp","Set","length","each","treeItem","filteredItemValue","itemKey","toLocaleLowerCase","toLowerCase","selectedNodes","type","concat","node","path","a","add","onSearch","value","useSelectedTree","highlightedTreeItem","setHighlightedItemId","stopPropagation","currentlyHighlightedItemId","highLightedItem","find","selectFirstChild","parent","selectParent","siblings","depth","currentIndex","findIndex","sibling","selectTopSideSibling","selectBottomSideSibling","hotkeyRef","useHighlightedTreeItem","className","s","container","tabIndex","onChange","currentTarget","canvasContainer","folderId","nextId","generate","itemsOnLevel","createFolder","name","generateForLevel","folders","currentDepth","reduce","acc","folder","size","startAt","Array","map","i","range","itemNumber","generateChildren","temp","folderArgs","App","combined","itemLength","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6820fc6f.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Tree_container__14Gk0\",\"canvasContainer\":\"Tree_canvasContainer__2vhw0\"};","import React from \"react\";\n\nexport type Props = {\n  height: number;\n  width: number;\n};\nexport const Canvas: React.FC<Props> = (props) => {\n  const ref = React.useRef<SVGSVGElement>(null);\n  const [viewBox, setViewBox] = React.useState([0, 0, 0, 0]);\n  React.useEffect(() => {\n    if (ref.current) {\n      setViewBox(autoBox(ref.current));\n    }\n  }, []);\n  return (\n    <svg\n      ref={ref}\n      display=\"block\"\n      height={props.height}\n      width={props.width}\n      viewBox={viewBox.join(\" \")}\n    >\n      {props.children}\n    </svg>\n  );\n};\n\nfunction autoBox(svg: SVGSVGElement) {\n  const { x, y, width, height } = svg.getBBox();\n  return [x, y, width, height];\n}\n","import React, { PropsWithChildren } from \"react\";\nimport { HierarchyNode } from \"d3\";\n\nimport { render } from \"./Cluster-d3\";\n\nexport type Props<T> = {\n  height: number;\n  highlightedItemId: string | undefined;\n  labelKey: keyof T;\n  tree: HierarchyNode<T>;\n  selectedItemIds: Set<string>;\n  width: number;\n};\nexport const Cluster = <T,>(props: PropsWithChildren<Props<T>>) => {\n  const ref = React.useRef<SVGGElement>(null);\n\n  React.useEffect(() => {\n    if (ref.current) {\n      render(ref.current, props);\n    }\n  }, [props]);\n  return <g ref={ref} />;\n};\n","import { select, tree } from \"d3\";\nimport { Props } from \"./Cluster\";\n\nexport const render = <T>(wrapper: SVGGElement, props: Props<T>) => {\n  const selection = select(wrapper);\n  selection.selectAll(\"g\").remove();\n\n  const pathWrapper = selection\n    .append(\"g\")\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"#555\")\n    .attr(\"stroke-opacity\", 0.4)\n    .attr(\"stroke-width\", 1.5);\n  const pointsWrapper = selection.append(\"g\");\n  const textWrapper = selection.append(\"g\");\n\n  const dx = 50;\n  const dy = props.width / (props.tree.height + 1);\n  const root = tree<T>().nodeSize([dx, dy])(props.tree);\n\n  pathWrapper\n    .selectAll(\"path\")\n    .data(root.links())\n    .join(\"path\")\n    .attr(\"stroke\", (d) => {\n      if (props.selectedItemIds.has(String(d.target.id))) {\n        return \"blue\";\n      } else {\n        return \"#555\";\n      }\n    })\n    .attr(\n      \"d\",\n      (d) => `\n        M${d.target.y},${d.target.x}\n        C${d.source.y + dy / 2},${d.target.x}\n         ${d.source.y + dy / 2},${d.source.x}\n         ${d.source.y},${d.source.x}\n      `\n    );\n\n  pointsWrapper\n    .selectAll(\"circle\")\n    .data(root.descendants())\n    .join(\"circle\")\n    .attr(\"cx\", (d) => d.y)\n    .attr(\"cy\", (d) => d.x)\n    .attr(\"fill\", (d) => (d.children ? \"#555\" : \"#999\"))\n    .attr(\"r\", 2.5);\n\n  textWrapper\n    .attr(\"font-family\", \"sans-serif\")\n    .attr(\"font-size\", 10)\n    .attr(\"stroke-linejoin\", \"round\")\n    .attr(\"stroke-width\", 3)\n    .selectAll(\"text\")\n    .data(root.descendants())\n    .join(\"text\")\n    .attr(\"x\", (d) => d.y)\n    .attr(\"y\", (d) => d.x)\n    .attr(\"dy\", \"0.31em\")\n    .attr(\"dx\", (d) => (d.children ? -6 : 6))\n    .attr(\"fill\", (d) => {\n      if (d.id === props.highlightedItemId) return \"red\";\n      // d.id && -> because d3 type is id?: string;\n      return d.id && props.selectedItemIds.has(d.id) ? \"blue\" : \"black\";\n    })\n    .text((d) => String(d.data[props.labelKey]))\n    .filter((d) => !!d.children)\n    .attr(\"text-anchor\", \"end\")\n    .clone(true)\n    .lower()\n    .attr(\"stroke\", \"white\");\n};\n","import React from \"react\";\n\ntype Cleanup = () => void;\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop: Cleanup = () => {};\n\ntype RefCallbackWithoutCleanup<RefElement extends HTMLElement> = (\n  element: RefElement | null\n) => void;\nexport type RefCallbackWithCleanup<RefElement extends HTMLElement> = (\n  element: RefElement\n) => () => void;\n\n/*\n * The idea of this hook is to generalize cleanup for RefCallback.\n * By default React.RefCallback doesn't support cleanup.\n * */\nexport function useRefCallbackWithCleanup<RefElement extends HTMLElement>(\n  callback: RefCallbackWithCleanup<RefElement>\n): RefCallbackWithoutCleanup<RefElement> {\n  const cleanUpRef = React.useRef<Cleanup>(noop);\n  return React.useCallback(\n    (element: RefElement | null) => {\n      cleanUpRef.current();\n      // So that every cleanup is called only once\n      cleanUpRef.current = noop;\n\n      if (element) {\n        cleanUpRef.current = callback(element);\n      }\n    },\n    [callback]\n  );\n}\n","import React from \"react\";\nimport {\n  RefCallbackWithCleanup,\n  useRefCallbackWithCleanup,\n} from \"./useRefCallbackWithCleanup\";\n\nexport type EventListener = {\n  keys: string[];\n  eventListener: (event: KeyboardEvent) => void;\n};\ntype Handler = (event: KeyboardEvent) => void;\ntype Props = {\n  autoFocus: boolean;\n  eventListeners: EventListener[];\n};\nexport const useHotkeys = <RefElement extends HTMLElement>(\n  props: Props\n): React.RefCallback<RefElement> => {\n  const { autoFocus, eventListeners } = props;\n  const refCallback: RefCallbackWithCleanup<RefElement> = React.useCallback(\n    (element) => {\n      const handlers: Handler[] = [];\n      eventListeners.forEach(({ keys, eventListener }) => {\n        const eventHandler = (event: KeyboardEvent) => {\n          if (keys.includes(event.key)) {\n            eventListener(event);\n          }\n        };\n        handlers.push(eventHandler);\n        element?.addEventListener(\"keydown\", eventHandler);\n      });\n\n      if (autoFocus) {\n        element?.focus();\n      }\n\n      return () => {\n        console.log(\"Cleanup time!\");\n        handlers.forEach((handler) => {\n          element?.removeEventListener(\"keydown\", handler);\n        });\n      };\n    },\n    [autoFocus, eventListeners]\n  );\n  return useRefCallbackWithCleanup<RefElement>(refCallback);\n};\n","import React, { PropsWithChildren } from \"react\";\n\nimport s from \"./Tree.module.css\";\n\nimport { BaseItem } from \"../../types\";\nimport { Canvas } from \"../Canvas\";\nimport { Cluster } from \"../Cluster\";\nimport { stratify } from \"../../utils/stratify\";\nimport { useSelectedTree } from \"../../../../hooks/useSelectedTree\";\nimport { useHighlightedTreeItem } from \"../../../../hooks/useHighlightedTreeItem\";\n\nexport type Props<T> = {\n  height: number;\n  idKey: keyof T;\n  items: T[];\n  labelKey: keyof T;\n  parentKey: keyof T;\n  width: number;\n};\nexport const Tree = <T extends BaseItem>(\n  props: PropsWithChildren<Props<T>>\n) => {\n  // In our app all d3 related stuff could be completely inside the useSelectedTree hook\n  // I have them here because Cluster takes tree as props\n  const tree = React.useMemo(\n    () => stratify(props.items, props.idKey, props.parentKey),\n    [props.items, props.idKey, props.parentKey]\n  );\n  const { search, onSearch, selectedItemIds } = useSelectedTree({\n    items: props.items,\n    itemKey: props.labelKey,\n    tree,\n  });\n\n  const highlightedTreeItem = useHighlightedTreeItem({ tree });\n\n  return (\n    <div\n      className={s.container}\n      tabIndex={0}\n      ref={highlightedTreeItem.hotkeyRef}\n    >\n      Press arrow keys to navigate! <br />\n      Search:{\" \"}\n      <input\n        type=\"text\"\n        value={search}\n        onChange={(event) => {\n          const value = event.currentTarget.value;\n          onSearch(value);\n        }}\n      />\n      <div className={s.canvasContainer}>\n        <Canvas height={props.height} width={props.width}>\n          <Cluster\n            height={props.height}\n            highlightedItemId={highlightedTreeItem.highlightedItemId}\n            labelKey={props.labelKey}\n            tree={tree}\n            selectedItemIds={selectedItemIds}\n            width={props.width}\n          />\n        </Canvas>\n      </div>\n    </div>\n  );\n};\n","import { stratify as d3Stratify } from \"d3\";\n\nexport const stratify = <T>(data: T[], id: keyof T, parentId: keyof T) => {\n  return d3Stratify<T>()\n    .id((d) => String(d[id]))\n    .parentId((d) => {\n      // For some reason null is not acceptable parentId and it that case it should be \"\"\n      // Maybe it has something to do with CSVs since this is supposed to be used for reading CSV data\n      return d[parentId] === null ? \"\" : String(d[parentId]);\n    })(data);\n};\n","import React, { useMemo } from \"react\";\nimport { HierarchyNode } from \"d3\";\n\nimport {\n  Props as UseSelectedItemsProps,\n  ReturnType as UseSelectedItemsReturnType,\n} from \"./useSelectedItems\";\nimport { BaseItem } from \"../features/d3-tree/types\";\n\ntype Props<T> = {\n  items: UseSelectedItemsProps<T>[\"items\"];\n  itemKey: UseSelectedItemsProps<T>[\"itemKey\"];\n  tree: HierarchyNode<T>;\n};\n\ntype ReturnType<T> = {\n  search: UseSelectedItemsReturnType<T>[\"search\"];\n  onSearch: UseSelectedItemsReturnType<T>[\"onSearch\"];\n  selectedItemIds: Set<string>;\n};\nexport const useSelectedTree = <T extends BaseItem>(\n  props: Props<T>\n): ReturnType<T> => {\n  const [search, setSearch] = React.useState(\"\");\n  const onSearch = (value: string): void => {\n    const resetSearch = (): void => {\n      setSearch(\"\");\n    };\n    if (value === \"\") return resetSearch();\n    // We are not setting filteredItems here on purpose. Setting only search string ends up in the effect\n    // few lines above.\n    // If hook receives new items we want to maintain the search and do it for the new items. This is\n    // why we have the effect and why it's not necessary the filter items in this function or in resetSearch\n    // setFilteredItems(doSearch(value));\n    setSearch(value);\n  };\n\n  const selectedItemIds = useMemo(() => {\n    const itemsTemp: Set<string> = new Set();\n    if (search.length === 0) {\n      return itemsTemp;\n    }\n    props.tree.each((treeItem) => {\n      const filteredItemValue = treeItem.data[props.itemKey];\n      if (\n        typeof filteredItemValue === \"string\" &&\n        filteredItemValue.toLocaleLowerCase().includes(search.toLowerCase())\n      ) {\n        let selectedNodes = [treeItem];\n        if (treeItem.data.type === \"folder\" && treeItem.children) {\n          selectedNodes = selectedNodes.concat(treeItem.children);\n        }\n        selectedNodes.forEach((node) => {\n          props.tree.path(node).forEach((a) => {\n            itemsTemp.add(String(a.data.id));\n          });\n        });\n      }\n    });\n    return itemsTemp;\n  }, [props.itemKey, props.tree, search]);\n\n  return {\n    search,\n    onSearch,\n    selectedItemIds,\n  };\n};\n\nfunction getSelectedNodes<T extends BaseItem>(\n  selectedItems: T[],\n  tree: HierarchyNode<T>\n): HierarchyNode<T>[] {\n  return selectedItems.flatMap((selectedItem) => {\n    // TODO It would be better to abstract folders and reports out from this and use more generic\n    // terms for node's which don't have children and which do.\n    // I think d3 uses \"leaf node\" and \"node\" respectively\n    if (selectedItem.type === \"folder\") {\n      //@ts-ignore missing from types\n      const treeItem = tree.find(\n        //@ts-ignore missing from types\n        (d) => String(d.id) === String(selectedItem.id)\n      );\n\n      return treeItem && treeItem.children ? treeItem.children : [];\n    } else {\n      //@ts-ignore missing from types\n      return [tree.find((d) => String(d.id) === String(selectedItem.id))];\n    }\n  });\n}\n\nfunction getSelectedNodesAndAllTheirParents<T extends BaseItem>(\n  tree: HierarchyNode<T>,\n  selectedNodes: HierarchyNode<T>[]\n): Set<string> {\n  // String(node.id) because of d3 type is id?: string; but we always have id\n  return new Set(\n    selectedNodes\n      .flatMap((node) => {\n        return tree.path(node);\n      })\n      .map((node) => String(node.id))\n  );\n}\n","import React from \"react\";\nimport { HierarchyNode } from \"d3\";\n\nimport { useHotkeys } from \"./useHotkeys\";\n\ntype Props<Item> = {\n  tree: HierarchyNode<Item>;\n};\ntype ReturnType<Element> = {\n  hotkeyRef: React.RefCallback<Element>;\n  highlightedItemId: string | undefined;\n};\nexport const useHighlightedTreeItem = <Item, Element extends HTMLElement>(\n  props: Props<Item>\n): ReturnType<Element> => {\n  const [highlightedItemId, setHighlightedItemId] = React.useState<\n    string | undefined\n  >(props.tree.id);\n\n  // When highlightedItemId or props.tree change the previous eventlisteners get cleaned up and new ones\n  // get attached. Probably can't do anything about it\n  const eventListeners = React.useMemo(\n    () => [\n      {\n        keys: [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"],\n        eventListener: (event: KeyboardEvent) => {\n          event.stopPropagation();\n          if (event.key === \"ArrowRight\") {\n            setHighlightedItemId(\n              selectFirstChild(props.tree, highlightedItemId)\n            );\n          } else if (event.key === \"ArrowLeft\") {\n            setHighlightedItemId(selectParent(props.tree, highlightedItemId));\n          } else if (event.key === \"ArrowUp\") {\n            setHighlightedItemId(\n              selectTopSideSibling(props.tree, highlightedItemId)\n            );\n          } else if (event.key === \"ArrowDown\") {\n            setHighlightedItemId(\n              selectBottomSideSibling(props.tree, highlightedItemId)\n            );\n          }\n        },\n      },\n    ],\n    [highlightedItemId, props.tree]\n  );\n  const hotkeyRef = useHotkeys({\n    autoFocus: true,\n    eventListeners,\n  });\n\n  return {\n    hotkeyRef,\n    highlightedItemId,\n  };\n};\n\nfunction selectFirstChild<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n  if (highLightedItem.children) {\n    return highLightedItem.children[0].id;\n  }\n  return currentlyHighlightedItemId;\n}\n\nfunction selectParent<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n  if (highLightedItem.parent) {\n    return highLightedItem.parent.id;\n  }\n  return currentlyHighlightedItemId;\n}\n\nfunction selectTopSideSibling<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n\n  const siblings: HierarchyNode<Item>[] = [];\n  tree.each((d: HierarchyNode<Item>) => {\n    if (d.depth === highLightedItem.depth) {\n      siblings.push(d);\n    }\n  });\n  const currentIndex = siblings.findIndex(\n    (sibling) => sibling.id === highLightedItem.id\n  );\n\n  if (siblings[currentIndex - 1]) {\n    return siblings[currentIndex - 1].id;\n  } else {\n    return highLightedItem.id;\n  }\n}\n\n// Copy-pasta for now!\nfunction selectBottomSideSibling<Item>(\n  tree: HierarchyNode<Item>,\n  currentlyHighlightedItemId: string | undefined\n) {\n  //@ts-ignore missing from types\n  const highLightedItem: HierarchyNode<Item> = tree.find(\n    (d: HierarchyNode<Item>) => d.id === currentlyHighlightedItemId\n  );\n\n  const siblings: HierarchyNode<Item>[] = [];\n  tree.each((d: HierarchyNode<Item>) => {\n    if (d.depth === highLightedItem.depth) {\n      siblings.push(d);\n    }\n  });\n  const currentIndex = siblings.findIndex(\n    (sibling) => sibling.id === highLightedItem.id\n  );\n\n  if (siblings[currentIndex + 1]) {\n    return siblings[currentIndex + 1].id;\n  } else {\n    return highLightedItem.id;\n  }\n}\n","import { range } from \"../utils/numberUtil\";\n\nlet folderId = 0;\nfunction nextId() {\n  const nextId = folderId + 1;\n  folderId = folderId + 1;\n  return nextId;\n}\n\ninterface BaseType {\n  type: string;\n}\n\ninterface Folder extends BaseType {\n  id: number;\n  name: string;\n  parentId: number | null;\n  type: \"folder\";\n}\n\ninterface Report extends BaseType {\n  id: number;\n  name: string;\n  parentId: number | null;\n  type: \"report\";\n}\n\nexport const generate = (depth: number, itemsOnLevel: number) => {\n  // console.log(\"fold id at start\", folderId);\n  const root = createFolder({ name: \"Root\", parentId: null });\n\n  // Yeah this isn't right :D\n  return [root].concat(generateForLevel([root], depth, itemsOnLevel, 1));\n};\n\nfunction generateForLevel(\n  folders: Folder[],\n  depth: number,\n  itemsOnLevel: number,\n  currentDepth: number\n): Folder[] {\n  return folders.reduce((acc: Folder[], folder) => {\n    const children = generateChildren(folder, currentDepth, itemsOnLevel);\n\n    let temp: Folder[] = [];\n    if (currentDepth < depth) {\n      temp = generateForLevel(children, depth, itemsOnLevel, currentDepth + 1);\n    }\n\n    return [...acc, ...children, ...temp];\n  }, []);\n}\n\nfunction generateChildren(\n  parent: Folder,\n  currentDepth: number,\n  itemsOnLevel: number\n): Folder[] {\n  return range(itemsOnLevel, 1).map((itemNumber) => {\n    return createFolder({\n      name: `Child item no. ${itemNumber} parent_id: ${parent.id} depth: ${currentDepth}`,\n      parentId: parent.id,\n    });\n  });\n}\n\nfunction createFolder(folderArgs: Omit<Folder, \"id\" | \"type\">): Folder {\n  return { ...folderArgs, id: nextId(), type: \"folder\" };\n}\n","export function range(size: number, startAt = 0) {\n  return [...Array(size).keys()].map((i) => i + startAt);\n}\n","import React from \"react\";\n\nimport { Tree } from \"./features/d3-tree\";\nimport { generate } from \"./dataGenerator\";\n\n/*\n * Perf results:\n *\n * generate(3, 10)\n * 1k nodes dev: useSelectedTree: 50ms which is ran 4 times. Whole thing with rendering ~270ms\n * 1k nodes prod: useSelectedTree: 80ms which is ran 2 times. Whole thing with rendering ~230ms\n *\n * optimized 1k nodes prod: useSelectedTree: ~100ms which is ran 1 times. Whole thing with rendering ~170ms\n * more optimized 1k nodes prod: useSelectedTree: ~100ms which is ran 1 times. Whole thing with rendering ~113ms\n *\n *\n * generate(3, 15)\n * optimized 3k nodes prod: useSelectedTree: ~800ms which is ran 1 times. Whole thing with rendering ~1s\n * more-optimized 3k nodes prod: useSelectedTree: ~800ms which is ran 1 times. Whole thing with rendering ~430ms\n *\n *\n * generate(3, 20)\n * 8k nodes dev: useSelectedTree: 2,5s which is ran 4 times. Whole thing with rendering ~10s\n * 8k nodes prod: useSelectedTree: 3,7s which is ran 2 times. Whole thing with rendering ~8s\n *\n * optimized 8k nodes dev: useSelectedTree: 2.5s which is ran 2 times. Whole thing with rendering ~5.6s\n * optimized 8k nodes prod: useSelectedTree: 3,7s which is ran 1 times. Whole thing with rendering ~4,5s\n *\n * more-optimized 8k nodes prod: useSelectedTree: 1.2s which is ran 1 times. Whole thing with rendering ~2s\n * -> Sometimes I get really weird results: search takes 20ms and whole thing around ~800ms\n * */\ninterface BaseType {\n  type: string;\n}\ninterface Folder extends BaseType {\n  id: number;\n  name: string;\n  parentId: number | null;\n  type: \"folder\";\n}\ninterface Report extends BaseType {\n  id: number;\n  name: string;\n  parentId: number | null;\n  type: \"report\";\n}\n\nconst folders: Folder[] = [\n  { id: 1, name: \"Root\", parentId: null, type: \"folder\" },\n  { id: 2, name: \"Cats\", parentId: 1, type: \"folder\" },\n  { id: 3, name: \"Dogs\", parentId: 1, type: \"folder\" },\n  { id: 4, name: \"Small\", parentId: 2, type: \"folder\" },\n  { id: 5, name: \"Big\", parentId: 2, type: \"folder\" },\n];\n\nconst reports: Report[] = [\n  { id: 10, name: \"Kitten\", parentId: 4, type: \"report\" },\n  { id: 20, name: \"Kitten2\", parentId: 4, type: \"report\" },\n  { id: 30, name: \"Buldog\", parentId: 3, type: \"report\" },\n  { id: 40, name: \"Under root\", parentId: 1, type: \"report\" },\n  { id: 50, name: \"Fatcat\", parentId: 5, type: \"report\" },\n];\n\nfunction App() {\n  // const combined: Array<Report | Folder> = [...folders, ...reports];\n  const combined = React.useMemo(() => generate(3, 20), []);\n  const itemLength = combined.length;\n  console.log(\"items in data structure: \", itemLength);\n  let height = 1000;\n  if (itemLength < 2000) {\n    height = 40000;\n  } else if (itemLength > 2000 && itemLength < 7000) {\n    height = 130000;\n  } else if (itemLength > 7000) {\n    height = 300000;\n  }\n  return (\n    <Tree\n      height={height}\n      idKey=\"id\"\n      items={combined}\n      labelKey=\"name\"\n      parentKey=\"parentId\"\n      width={500}\n    />\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\n\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}